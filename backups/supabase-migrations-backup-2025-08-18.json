{
  "20250807124425_cleanup_obsolete_tables.sql": {
    "sql": "-- ========================================\r\n-- EDGE Application Database Cleanup Script\r\n-- Phase 1-3: Complete cleanup of obsolete tables\r\n-- ========================================\r\n-- Generated: 2025-08-07\r\n-- Purpose: Remove 8 confirmed obsolete tables that are no longer used\r\n--\r\n-- SAFETY MEASURES:\r\n-- 1. Creates backup/archive tables before deletion\r\n-- 2. Documents current row counts\r\n-- 3. Uses IF EXISTS clauses to prevent errors\r\n-- 4. Verifies no active dependencies\r\n\r\n-- ========================================\r\n-- PHASE 1: PRE-CLEANUP SAFETY MEASURES\r\n-- ========================================\r\n\r\n-- Document current state with row counts\r\nSELECT 'admin_backup' as table_name, COUNT(*) as row_count FROM admin_backup\r\nUNION ALL\r\nSELECT 'assessment_feedback' as table_name, COUNT(*) as row_count FROM assessment_feedback\r\nUNION ALL\r\nSELECT 'assessment_rocks' as table_name, COUNT(*) as row_count FROM assessment_rocks\r\nUNION ALL\r\nSELECT 'assessment_scorecard_metrics' as table_name, COUNT(*) as row_count FROM assessment_scorecard_metrics\r\nUNION ALL\r\nSELECT 'company_rocks' as table_name, COUNT(*) as row_count FROM company_rocks\r\nUNION ALL\r\nSELECT 'employee_development_goals' as table_name, COUNT(*) as row_count FROM employee_development_goals\r\nUNION ALL\r\nSELECT 'manager_employee_messages' as table_name, COUNT(*) as row_count FROM manager_employee_messages\r\nUNION ALL\r\nSELECT 'training_requests' as table_name, COUNT(*) as row_count FROM training_requests;\r\n\r\n-- Create archive tables (backup before deletion)\r\n-- Note: Archives will have _archive suffix and include cleanup timestamp\r\n\r\nCREATE TABLE IF NOT EXISTS admin_backup_archive AS \r\nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\r\nFROM admin_backup;\r\n\r\nCREATE TABLE IF NOT EXISTS assessment_feedback_archive AS \r\nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\r\nFROM assessment_feedback;\r\n\r\nCREATE TABLE IF NOT EXISTS assessment_rocks_archive AS \r\nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\r\nFROM assessment_rocks;\r\n\r\nCREATE TABLE IF NOT EXISTS assessment_scorecard_metrics_archive AS \r\nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\r\nFROM assessment_scorecard_metrics;\r\n\r\nCREATE TABLE IF NOT EXISTS company_rocks_archive AS \r\nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\r\nFROM company_rocks;\r\n\r\nCREATE TABLE IF NOT EXISTS employee_development_goals_archive AS \r\nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\r\nFROM employee_development_goals;\r\n\r\nCREATE TABLE IF NOT EXISTS manager_employee_messages_archive AS \r\nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\r\nFROM manager_employee_messages;\r\n\r\nCREATE TABLE IF NOT EXISTS training_requests_archive AS \r\nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\r\nFROM training_requests;\r\n\r\n-- Check for any foreign key dependencies that might prevent cleanup\r\nSELECT DISTINCT\r\n    tc.constraint_name,\r\n    tc.table_name,\r\n    kcu.column_name,\r\n    ccu.table_name AS foreign_table_name,\r\n    ccu.column_name AS foreign_column_name\r\nFROM information_schema.table_constraints AS tc\r\nJOIN information_schema.key_column_usage AS kcu\r\n    ON tc.constraint_name = kcu.constraint_name\r\nJOIN information_schema.constraint_column_usage AS ccu\r\n    ON ccu.constraint_name = tc.constraint_name\r\nWHERE tc.constraint_type = 'FOREIGN KEY'\r\n    AND (tc.table_name IN (\r\n        'admin_backup',\r\n        'assessment_feedback',\r\n        'assessment_rocks', \r\n        'assessment_scorecard_metrics',\r\n        'company_rocks',\r\n        'employee_development_goals',\r\n        'manager_employee_messages',\r\n        'training_requests'\r\n    ) \r\n    OR ccu.table_name IN (\r\n        'admin_backup',\r\n        'assessment_feedback',\r\n        'assessment_rocks',\r\n        'assessment_scorecard_metrics', \r\n        'company_rocks',\r\n        'employee_development_goals',\r\n        'manager_employee_messages',\r\n        'training_requests'\r\n    ));\r\n\r\n-- ========================================\r\n-- PHASE 2: EXECUTE CLEANUP \r\n-- ========================================\r\n\r\n-- Drop the 8 confirmed obsolete tables\r\n-- Using IF EXISTS to prevent errors if tables don't exist\r\n\r\nDROP TABLE IF EXISTS admin_backup CASCADE;\r\nDROP TABLE IF EXISTS assessment_feedback CASCADE;\r\nDROP TABLE IF EXISTS assessment_rocks CASCADE;\r\nDROP TABLE IF EXISTS assessment_scorecard_metrics CASCADE;\r\nDROP TABLE IF EXISTS company_rocks CASCADE;\r\nDROP TABLE IF EXISTS employee_development_goals CASCADE;\r\nDROP TABLE IF EXISTS manager_employee_messages CASCADE;\r\nDROP TABLE IF EXISTS training_requests CASCADE;",
    "path": "supabase/migrations/20250807124425_cleanup_obsolete_tables.sql"
  },
  "20250807160000_add_delete_feedback_function.sql": {
    "sql": "-- ================================================================\r\n-- EDGE App Admin Feedback Management\r\n-- Migration: 20250807160000_add_delete_feedback_function.sql\r\n-- Purpose: Allow admins to delete inappropriate feedback from the feedback wall\r\n-- ================================================================\r\n\r\n-- Drop function if it exists to avoid conflicts\r\nDROP FUNCTION IF EXISTS public.delete_feedback(bigint);\r\n\r\n-- Function to delete feedback (admin only)\r\nCREATE OR REPLACE FUNCTION public.delete_feedback(\r\n    p_feedback_id bigint\r\n)\r\nRETURNS json AS $$\r\nDECLARE\r\n    current_user_role text;\r\n    feedback_exists boolean;\r\n    current_user_active boolean;\r\nBEGIN\r\n    -- Get current user role and active status from employees table\r\n    SELECT role, is_active INTO current_user_role, current_user_active\r\n    FROM public.employees \r\n    WHERE user_id = auth.uid();\r\n    \r\n    -- Check if user exists and is active\r\n    IF current_user_role IS NULL OR NOT current_user_active THEN\r\n        RETURN json_build_object('error', 'User not found or inactive.');\r\n    END IF;\r\n    \r\n    -- Check if user is admin\r\n    IF current_user_role != 'admin' THEN\r\n        RETURN json_build_object('error', 'Access denied. Only admins can delete feedback.');\r\n    END IF;\r\n    \r\n    -- Check if feedback exists\r\n    SELECT EXISTS(\r\n        SELECT 1 FROM public.feedback \r\n        WHERE id = p_feedback_id\r\n    ) INTO feedback_exists;\r\n    \r\n    IF NOT feedback_exists THEN\r\n        RETURN json_build_object('error', 'Feedback not found.');\r\n    END IF;\r\n    \r\n    -- Delete the feedback\r\n    DELETE FROM public.feedback \r\n    WHERE id = p_feedback_id;\r\n    \r\n    -- Verify deletion was successful\r\n    IF NOT FOUND THEN\r\n        RETURN json_build_object('error', 'Failed to delete feedback.');\r\n    END IF;\r\n    \r\n    RETURN json_build_object(\r\n        'success', true,\r\n        'message', 'Feedback deleted successfully',\r\n        'feedback_id', p_feedback_id\r\n    );\r\nEND;\r\n$$ LANGUAGE plpgsql SECURITY DEFINER;\r\n\r\n-- Grant execute permission to authenticated users\r\nGRANT EXECUTE ON FUNCTION public.delete_feedback(bigint) TO authenticated;\r\n\r\n-- Add comment for documentation\r\nCOMMENT ON FUNCTION public.delete_feedback(bigint) IS 'Allows admin users to delete inappropriate feedback from the feedback wall';\r\n\r\n-- Migration complete\r\nSELECT 'Migration 20250807160000_add_delete_feedback_function completed successfully' as status;",
    "path": "supabase/migrations/20250807160000_add_delete_feedback_function.sql"
  },
  "20250808000001_enforce_unique_user_id.sql": {
    "sql": "-- Migration: Enforce 1:1 employeeâ†”auth mapping\r\n-- Description: Add unique constraint on employees.user_id to prevent duplicate auth mappings\r\n-- Issue: Multiple employee records could reference the same auth user, breaking RLS logic\r\n\r\n-- Step 1: Check for and resolve any existing duplicates (safety check)\r\n-- This will identify any duplicate user_id values that would prevent the unique constraint\r\nDO $$\r\nDECLARE\r\n    duplicate_count INTEGER;\r\n    duplicate_record RECORD;\r\nBEGIN\r\n    -- Check for existing duplicates\r\n    SELECT COUNT(*) INTO duplicate_count\r\n    FROM (\r\n        SELECT user_id \r\n        FROM public.employees \r\n        WHERE user_id IS NOT NULL\r\n        GROUP BY user_id \r\n        HAVING COUNT(*) > 1\r\n    ) dups;\r\n    \r\n    IF duplicate_count > 0 THEN\r\n        RAISE NOTICE 'Found % duplicate user_id values in employees table', duplicate_count;\r\n        \r\n        -- List the duplicates for manual review\r\n        FOR duplicate_record IN \r\n            SELECT user_id, string_agg(id::text || ':' || email, ', ') as records\r\n            FROM public.employees \r\n            WHERE user_id IS NOT NULL\r\n            GROUP BY user_id \r\n            HAVING COUNT(*) > 1\r\n        LOOP\r\n            RAISE NOTICE 'Duplicate user_id %: records %', duplicate_record.user_id, duplicate_record.records;\r\n        END LOOP;\r\n        \r\n        RAISE EXCEPTION 'Cannot add unique constraint: duplicate user_id values exist. Please resolve manually.';\r\n    END IF;\r\n    \r\n    RAISE NOTICE 'No duplicates found. Safe to proceed with unique constraint.';\r\nEND $$;\r\n\r\n-- Step 2: Add the unique constraint\r\n-- This ensures each auth.users.id can only be referenced by one employee record\r\nCREATE UNIQUE INDEX IF NOT EXISTS uq_employees_user_id \r\nON public.employees(user_id) \r\nWHERE user_id IS NOT NULL;\r\n\r\n-- Step 3: Add a comment explaining the constraint\r\nCOMMENT ON INDEX uq_employees_user_id IS \r\n'Ensures 1:1 mapping between auth.users and employees. Critical for RLS policy correctness.';\r\n\r\n-- Verification query (will be logged in migration output)\r\nSELECT \r\n    'Migration completed successfully' as status,\r\n    COUNT(*) as total_employees,\r\n    COUNT(DISTINCT user_id) as unique_user_ids,\r\n    COUNT(*) - COUNT(user_id) as null_user_ids\r\nFROM public.employees;",
    "path": "supabase/migrations/20250808000001_enforce_unique_user_id.sql"
  },
  "20250808000002_admin_write_policies.sql": {
    "sql": "-- Migration: Add admin WITH CHECK policies for write operations\r\n-- Description: Ensure admin users can reliably perform INSERT/UPDATE operations\r\n-- Issue: Missing WITH CHECK policies can cause unpredictable write failures for admins\r\n\r\n-- Step 1: Add WITH CHECK policies for employees table\r\nDO $$ \r\nBEGIN\r\n    -- Admin INSERT policy\r\n    IF NOT EXISTS (\r\n        SELECT 1 FROM pg_policies \r\n        WHERE schemaname='public' AND tablename='employees' AND policyname='admin_insert_employees'\r\n    ) THEN\r\n        CREATE POLICY admin_insert_employees \r\n        ON public.employees FOR INSERT\r\n        WITH CHECK (\r\n            EXISTS (\r\n                SELECT 1 FROM public.employees me \r\n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\r\n            )\r\n        );\r\n        RAISE NOTICE 'Created admin_insert_employees policy';\r\n    ELSE\r\n        RAISE NOTICE 'Policy admin_insert_employees already exists';\r\n    END IF;\r\n\r\n    -- Admin UPDATE policy (both USING and WITH CHECK)\r\n    IF NOT EXISTS (\r\n        SELECT 1 FROM pg_policies \r\n        WHERE schemaname='public' AND tablename='employees' AND policyname='admin_update_employees'\r\n    ) THEN\r\n        CREATE POLICY admin_update_employees \r\n        ON public.employees FOR UPDATE\r\n        USING (\r\n            EXISTS (\r\n                SELECT 1 FROM public.employees me \r\n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\r\n            )\r\n        )\r\n        WITH CHECK (\r\n            EXISTS (\r\n                SELECT 1 FROM public.employees me \r\n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\r\n            )\r\n        );\r\n        RAISE NOTICE 'Created admin_update_employees policy';\r\n    ELSE\r\n        RAISE NOTICE 'Policy admin_update_employees already exists';\r\n    END IF;\r\nEND $$;\r\n\r\n-- Step 2: Add WITH CHECK policies for assessments table\r\nDO $$ \r\nBEGIN\r\n    -- Admin INSERT policy for assessments\r\n    IF NOT EXISTS (\r\n        SELECT 1 FROM pg_policies \r\n        WHERE schemaname='public' AND tablename='assessments' AND policyname='admin_insert_assessments'\r\n    ) THEN\r\n        CREATE POLICY admin_insert_assessments \r\n        ON public.assessments FOR INSERT\r\n        WITH CHECK (\r\n            EXISTS (\r\n                SELECT 1 FROM public.employees me \r\n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\r\n            )\r\n        );\r\n        RAISE NOTICE 'Created admin_insert_assessments policy';\r\n    ELSE\r\n        RAISE NOTICE 'Policy admin_insert_assessments already exists';\r\n    END IF;\r\n\r\n    -- Admin UPDATE policy for assessments\r\n    IF NOT EXISTS (\r\n        SELECT 1 FROM pg_policies \r\n        WHERE schemaname='public' AND tablename='assessments' AND policyname='admin_update_assessments'\r\n    ) THEN\r\n        CREATE POLICY admin_update_assessments \r\n        ON public.assessments FOR UPDATE\r\n        USING (\r\n            EXISTS (\r\n                SELECT 1 FROM public.employees me \r\n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\r\n            )\r\n        )\r\n        WITH CHECK (\r\n            EXISTS (\r\n                SELECT 1 FROM public.employees me \r\n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\r\n            )\r\n        );\r\n        RAISE NOTICE 'Created admin_update_assessments policy';\r\n    ELSE\r\n        RAISE NOTICE 'Policy admin_update_assessments already exists';\r\n    END IF;\r\nEND $$;\r\n\r\n-- Step 3: Add WITH CHECK policies for review_cycles table\r\nDO $$ \r\nBEGIN\r\n    -- Admin INSERT policy for review_cycles\r\n    IF NOT EXISTS (\r\n        SELECT 1 FROM pg_policies \r\n        WHERE schemaname='public' AND tablename='review_cycles' AND policyname='admin_insert_review_cycles'\r\n    ) THEN\r\n        CREATE POLICY admin_insert_review_cycles \r\n        ON public.review_cycles FOR INSERT\r\n        WITH CHECK (\r\n            EXISTS (\r\n                SELECT 1 FROM public.employees me \r\n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\r\n            )\r\n        );\r\n        RAISE NOTICE 'Created admin_insert_review_cycles policy';\r\n    ELSE\r\n        RAISE NOTICE 'Policy admin_insert_review_cycles already exists';\r\n    END IF;\r\n\r\n    -- Admin UPDATE policy for review_cycles\r\n    IF NOT EXISTS (\r\n        SELECT 1 FROM pg_policies \r\n        WHERE schemaname='public' AND tablename='review_cycles' AND policyname='admin_update_review_cycles'\r\n    ) THEN\r\n        CREATE POLICY admin_update_review_cycles \r\n        ON public.review_cycles FOR UPDATE\r\n        USING (\r\n            EXISTS (\r\n                SELECT 1 FROM public.employees me \r\n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\r\n            )\r\n        )\r\n        WITH CHECK (\r\n            EXISTS (\r\n                SELECT 1 FROM public.employees me \r\n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\r\n            )\r\n        );\r\n        RAISE NOTICE 'Created admin_update_review_cycles policy';\r\n    ELSE\r\n        RAISE NOTICE 'Policy admin_update_review_cycles already exists';\r\n    END IF;\r\nEND $$;\r\n\r\n-- Step 4: Add WITH CHECK policies for development_plans table  \r\nDO $$ \r\nBEGIN\r\n    -- Admin INSERT policy for development_plans\r\n    IF NOT EXISTS (\r\n        SELECT 1 FROM pg_policies \r\n        WHERE schemaname='public' AND tablename='development_plans' AND policyname='admin_insert_development_plans'\r\n    ) THEN\r\n        CREATE POLICY admin_insert_development_plans \r\n        ON public.development_plans FOR INSERT\r\n        WITH CHECK (\r\n            EXISTS (\r\n                SELECT 1 FROM public.employees me \r\n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\r\n            )\r\n        );\r\n        RAISE NOTICE 'Created admin_insert_development_plans policy';\r\n    ELSE\r\n        RAISE NOTICE 'Policy admin_insert_development_plans already exists';\r\n    END IF;\r\n\r\n    -- Admin UPDATE policy for development_plans\r\n    IF NOT EXISTS (\r\n        SELECT 1 FROM pg_policies \r\n        WHERE schemaname='public' AND tablename='development_plans' AND policyname='admin_update_development_plans'\r\n    ) THEN\r\n        CREATE POLICY admin_update_development_plans \r\n        ON public.development_plans FOR UPDATE\r\n        USING (\r\n            EXISTS (\r\n                SELECT 1 FROM public.employees me \r\n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\r\n            )\r\n        )\r\n        WITH CHECK (\r\n            EXISTS (\r\n                SELECT 1 FROM public.employees me \r\n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\r\n            )\r\n        );\r\n        RAISE NOTICE 'Created admin_update_development_plans policy';\r\n    ELSE\r\n        RAISE NOTICE 'Policy admin_update_development_plans already exists';\r\n    END IF;\r\nEND $$;\r\n\r\n-- Step 5: Verification - List all policies created\r\nSELECT \r\n    'Policy Summary' as status,\r\n    tablename,\r\n    policyname,\r\n    cmd as operation,\r\n    CASE WHEN qual IS NOT NULL THEN 'USING' END as using_clause,\r\n    CASE WHEN with_check IS NOT NULL THEN 'WITH CHECK' END as with_check_clause\r\nFROM pg_policies \r\nWHERE schemaname = 'public' \r\n  AND policyname LIKE 'admin_%'\r\nORDER BY tablename, policyname;",
    "path": "supabase/migrations/20250808000002_admin_write_policies.sql"
  },
  "20250808000003_performance_indexes.sql": {
    "sql": "-- Migration: Add performance indexes for RLS hotpaths and common joins\r\n-- Description: Optimize query performance for RLS policies and frequently joined columns\r\n\r\n-- Step 1: Index for active manager lookups (common in RLS policies)\r\nCREATE INDEX IF NOT EXISTS ix_employees_manager_active \r\nON public.employees(manager_id) \r\nWHERE is_active = true;\r\n\r\n-- Step 2: Index for employee + review cycle joins (very common)\r\nCREATE INDEX IF NOT EXISTS ix_assessments_employee_cycle \r\nON public.assessments(employee_id, review_cycle_id);\r\n\r\n-- Step 3: Index for user_id lookups (critical for RLS performance)\r\nCREATE INDEX IF NOT EXISTS ix_employees_user_id_active\r\nON public.employees(user_id)\r\nWHERE is_active = true;\r\n\r\n-- Step 4: Index for employee role lookups (admin checks)\r\nCREATE INDEX IF NOT EXISTS ix_employees_role_active\r\nON public.employees(role)\r\nWHERE is_active = true;\r\n\r\n-- Step 5: Index for kudos display and filtering\r\nCREATE INDEX IF NOT EXISTS ix_kudos_created\r\nON public.kudos(created_at DESC);\r\n\r\n-- Step 6: Conditional indexes based on actual table structure\r\nDO $$\r\nBEGIN\r\n    -- Check if team_health_pulse_responses table exists with correct columns\r\n    IF EXISTS (\r\n        SELECT 1 FROM information_schema.columns \r\n        WHERE table_schema = 'public' \r\n        AND table_name = 'team_health_pulse_responses' \r\n        AND column_name = 'submitted_at'\r\n    ) THEN\r\n        CREATE INDEX IF NOT EXISTS ix_pulse_responses_employee_date\r\n        ON public.team_health_pulse_responses(employee_id, submitted_at);\r\n        RAISE NOTICE 'Created index on pulse responses';\r\n    ELSE\r\n        RAISE NOTICE 'Skipped pulse responses index - table/column not found';\r\n    END IF;\r\n\r\n    -- Check if development_plans table exists with manager_approved column\r\n    IF EXISTS (\r\n        SELECT 1 FROM information_schema.columns \r\n        WHERE table_schema = 'public' \r\n        AND table_name = 'development_plans'\r\n        AND column_name = 'manager_approved'\r\n    ) THEN\r\n        CREATE INDEX IF NOT EXISTS ix_development_plans_employee_approved\r\n        ON public.development_plans(employee_id, manager_approved);\r\n        RAISE NOTICE 'Created index on development plans with manager_approved';\r\n    ELSIF EXISTS (\r\n        SELECT 1 FROM information_schema.tables \r\n        WHERE table_schema = 'public' \r\n        AND table_name = 'development_plans'\r\n    ) THEN\r\n        -- Table exists but column doesn't - create basic employee index\r\n        CREATE INDEX IF NOT EXISTS ix_development_plans_employee\r\n        ON public.development_plans(employee_id);\r\n        RAISE NOTICE 'Created basic index on development plans (manager_approved column not found)';\r\n    ELSE\r\n        RAISE NOTICE 'Skipped development plans index - table not found';\r\n    END IF;\r\n\r\n    -- Check if assessments table has type column\r\n    IF EXISTS (\r\n        SELECT 1 FROM information_schema.columns \r\n        WHERE table_schema = 'public' \r\n        AND table_name = 'assessments'\r\n        AND column_name = 'type'\r\n    ) THEN\r\n        CREATE INDEX IF NOT EXISTS ix_assessments_status_type\r\n        ON public.assessments(status, type);\r\n        RAISE NOTICE 'Created index on assessments status and type';\r\n    ELSE\r\n        -- Create basic status index without type\r\n        CREATE INDEX IF NOT EXISTS ix_assessments_status\r\n        ON public.assessments(status);\r\n        RAISE NOTICE 'Created basic status index on assessments (type column not found)';\r\n    END IF;\r\nEND $$;\r\n\r\n-- Verification: Display created indexes\r\nSELECT \r\n    'Index Summary' as status,\r\n    schemaname,\r\n    tablename, \r\n    indexname,\r\n    indexdef\r\nFROM pg_indexes \r\nWHERE schemaname = 'public'\r\n  AND indexname LIKE 'ix_%'\r\nORDER BY tablename, indexname;",
    "path": "supabase/migrations/20250808000003_performance_indexes.sql"
  },
  "20250808000004_set_based_review_seeding.sql": {
    "sql": "-- Migration: Replace row-loop seeding with set-based operations\r\n-- Description: Create scalable, idempotent review cycle seeding functions\r\n-- Issue: Current seeding may use inefficient row-by-row loops instead of set operations\r\n\r\n-- Function: Seed self-assessments for all active employees in a review cycle\r\nCREATE OR REPLACE FUNCTION seed_self_assessments(p_review_cycle_id UUID)\r\nRETURNS TABLE(\r\n    employees_processed INTEGER,\r\n    assessments_created INTEGER,\r\n    assessments_existing INTEGER\r\n) \r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public\r\nAS $$\r\nDECLARE\r\n    total_employees INTEGER;\r\n    new_assessments INTEGER;\r\n    existing_assessments INTEGER;\r\nBEGIN\r\n    -- Count total active employees\r\n    SELECT COUNT(*) INTO total_employees\r\n    FROM employees \r\n    WHERE is_active = true;\r\n    \r\n    -- Set-based insert with conflict handling\r\n    INSERT INTO assessments (employee_id, review_cycle_id, status, created_at)\r\n    SELECT \r\n        e.id,\r\n        p_review_cycle_id,\r\n        'draft',\r\n        now()\r\n    FROM employees e\r\n    WHERE e.is_active = true\r\n    ON CONFLICT (employee_id, review_cycle_id) DO NOTHING;\r\n    \r\n    -- Count what was actually inserted\r\n    GET DIAGNOSTICS new_assessments = ROW_COUNT;\r\n    \r\n    -- Calculate existing assessments\r\n    existing_assessments := total_employees - new_assessments;\r\n    \r\n    -- Log the operation\r\n    RAISE NOTICE 'Seeded % assessments for review cycle %, % already existed', \r\n        new_assessments, p_review_cycle_id, existing_assessments;\r\n    \r\n    -- Return summary\r\n    RETURN QUERY SELECT total_employees, new_assessments, existing_assessments;\r\nEND;\r\n$$;\r\n\r\n-- Function: Combined seeding for review cycle assessments\r\nCREATE OR REPLACE FUNCTION seed_review_cycle_assessments(p_review_cycle_id UUID)\r\nRETURNS TABLE(\r\n    cycle_name TEXT,\r\n    total_employees INTEGER,\r\n    assessments_created INTEGER,\r\n    assessments_existing INTEGER\r\n)\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public\r\nAS $$\r\nDECLARE\r\n    v_cycle_name TEXT;\r\n    seed_result RECORD;\r\nBEGIN\r\n    -- Verify review cycle exists and get name\r\n    SELECT name INTO v_cycle_name\r\n    FROM review_cycles\r\n    WHERE id = p_review_cycle_id;\r\n    \r\n    IF v_cycle_name IS NULL THEN\r\n        RAISE EXCEPTION 'Review cycle % not found', p_review_cycle_id;\r\n    END IF;\r\n    \r\n    -- Seed assessments using the simpler function\r\n    SELECT * INTO seed_result\r\n    FROM seed_self_assessments(p_review_cycle_id);\r\n    \r\n    -- Return comprehensive summary\r\n    RETURN QUERY SELECT \r\n        v_cycle_name,\r\n        seed_result.employees_processed,\r\n        seed_result.assessments_created,\r\n        seed_result.assessments_existing;\r\nEND;\r\n$$;\r\n\r\n-- Grant execute permissions to authenticated users (admins will use this via RLS)\r\nGRANT EXECUTE ON FUNCTION seed_self_assessments(UUID) TO authenticated;\r\nGRANT EXECUTE ON FUNCTION seed_review_cycle_assessments(UUID) TO authenticated;\r\n\r\n-- Add helpful comments\r\nCOMMENT ON FUNCTION seed_self_assessments(UUID) IS \r\n'Set-based seeding of assessments for all active employees. Idempotent via ON CONFLICT.';\r\n\r\nCOMMENT ON FUNCTION seed_review_cycle_assessments(UUID) IS \r\n'Complete seeding function for review cycle assessments. Returns detailed summary.';\r\n\r\n-- Safe verification without testing (avoids UUID casting issues)\r\nDO $$\r\nDECLARE\r\n    cycle_count INTEGER;\r\nBEGIN\r\n    -- Count existing review cycles\r\n    SELECT COUNT(*) INTO cycle_count FROM review_cycles;\r\n    \r\n    IF cycle_count > 0 THEN\r\n        RAISE NOTICE 'Functions created successfully. Found % review cycles available for seeding.', cycle_count;\r\n        RAISE NOTICE 'To test: SELECT * FROM seed_review_cycle_assessments(''your-cycle-id-here'');';\r\n    ELSE\r\n        RAISE NOTICE 'Functions created successfully. No review cycles found - create one to test seeding.';\r\n    END IF;\r\n    \r\n    RAISE NOTICE 'Migration completed: Set-based review seeding functions are ready for use.';\r\nEND $$;",
    "path": "supabase/migrations/20250808000004_set_based_review_seeding.sql"
  },
  "20250809000001_lucerne_tenant_setup.sql": {
    "sql": "-- Migration: Lucerne International Tenant Setup\r\n-- Description: Add multi-tenant support with RLS policies for client isolation\r\n-- Client: Lucerne International (@lucerneintl.com)\r\n-- Date: 2025-08-09\r\n\r\n-- Add tenant_id column to all main tables if not exists\r\nALTER TABLE IF EXISTS employees \r\nADD COLUMN IF NOT EXISTS tenant_id TEXT DEFAULT 'lucerne';\r\n\r\nALTER TABLE IF EXISTS assessments \r\nADD COLUMN IF NOT EXISTS tenant_id TEXT DEFAULT 'lucerne';\r\n\r\nALTER TABLE IF EXISTS review_cycles \r\nADD COLUMN IF NOT EXISTS tenant_id TEXT DEFAULT 'lucerne';\r\n\r\nALTER TABLE IF EXISTS goals \r\nADD COLUMN IF NOT EXISTS tenant_id TEXT DEFAULT 'lucerne';\r\n\r\nALTER TABLE IF EXISTS feedback \r\nADD COLUMN IF NOT EXISTS tenant_id TEXT DEFAULT 'lucerne';\r\n\r\nALTER TABLE IF EXISTS notifications \r\nADD COLUMN IF NOT EXISTS tenant_id TEXT DEFAULT 'lucerne';\r\n\r\n-- Create tenants table for managing client organizations\r\nCREATE TABLE IF NOT EXISTS tenants (\r\n    id TEXT PRIMARY KEY,\r\n    name TEXT NOT NULL,\r\n    domain TEXT NOT NULL UNIQUE,\r\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\r\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\r\n    is_active BOOLEAN DEFAULT TRUE,\r\n    settings JSONB DEFAULT '{}'::jsonb\r\n);\r\n\r\n-- Insert Lucerne as first tenant\r\nINSERT INTO tenants (id, name, domain) \r\nVALUES ('lucerne', 'Lucerne International', 'lucerneintl.com')\r\nON CONFLICT (id) DO NOTHING;\r\n\r\n-- Enable RLS on all tables\r\nALTER TABLE employees ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE assessments ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE review_cycles ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE goals ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE feedback ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE notifications ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE tenants ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Drop existing policies if they exist\r\nDROP POLICY IF EXISTS \"tenant_isolation_employees\" ON employees;\r\nDROP POLICY IF EXISTS \"tenant_isolation_assessments\" ON assessments;\r\nDROP POLICY IF EXISTS \"tenant_isolation_review_cycles\" ON review_cycles;\r\nDROP POLICY IF EXISTS \"tenant_isolation_goals\" ON goals;\r\nDROP POLICY IF EXISTS \"tenant_isolation_feedback\" ON feedback;\r\nDROP POLICY IF EXISTS \"tenant_isolation_notifications\" ON notifications;\r\n\r\n-- Create RLS policies for tenant isolation\r\nCREATE POLICY \"tenant_isolation_employees\" ON employees\r\n    FOR ALL USING (\r\n        tenant_id = COALESCE(current_setting('app.tenant_id', true), 'lucerne')\r\n        OR EXISTS (\r\n            SELECT 1 FROM employees \r\n            WHERE email = auth.jwt() ->> 'email' \r\n            AND role IN ('super_admin', 'system_admin')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"tenant_isolation_assessments\" ON assessments\r\n    FOR ALL USING (\r\n        tenant_id = COALESCE(current_setting('app.tenant_id', true), 'lucerne')\r\n        OR EXISTS (\r\n            SELECT 1 FROM employees \r\n            WHERE email = auth.jwt() ->> 'email' \r\n            AND role IN ('super_admin', 'system_admin')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"tenant_isolation_review_cycles\" ON review_cycles\r\n    FOR ALL USING (\r\n        tenant_id = COALESCE(current_setting('app.tenant_id', true), 'lucerne')\r\n        OR EXISTS (\r\n            SELECT 1 FROM employees \r\n            WHERE email = auth.jwt() ->> 'email' \r\n            AND role IN ('super_admin', 'system_admin')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"tenant_isolation_goals\" ON goals\r\n    FOR ALL USING (\r\n        tenant_id = COALESCE(current_setting('app.tenant_id', true), 'lucerne')\r\n        OR EXISTS (\r\n            SELECT 1 FROM employees \r\n            WHERE email = auth.jwt() ->> 'email' \r\n            AND role IN ('super_admin', 'system_admin')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"tenant_isolation_feedback\" ON feedback\r\n    FOR ALL USING (\r\n        tenant_id = COALESCE(current_setting('app.tenant_id', true), 'lucerne')\r\n        OR EXISTS (\r\n            SELECT 1 FROM employees \r\n            WHERE email = auth.jwt() ->> 'email' \r\n            AND role IN ('super_admin', 'system_admin')\r\n        )\r\n    );\r\n\r\nCREATE POLICY \"tenant_isolation_notifications\" ON notifications\r\n    FOR ALL USING (\r\n        tenant_id = COALESCE(current_setting('app.tenant_id', true), 'lucerne')\r\n        OR EXISTS (\r\n            SELECT 1 FROM employees \r\n            WHERE email = auth.jwt() ->> 'email' \r\n            AND role IN ('super_admin', 'system_admin')\r\n        )\r\n    );\r\n\r\n-- Tenants table policy - only super admins can manage tenants\r\nCREATE POLICY \"tenants_admin_only\" ON tenants\r\n    FOR ALL USING (\r\n        EXISTS (\r\n            SELECT 1 FROM employees \r\n            WHERE email = auth.jwt() ->> 'email' \r\n            AND role IN ('super_admin', 'system_admin')\r\n        )\r\n    );\r\n\r\n-- Create function to set tenant context\r\nCREATE OR REPLACE FUNCTION set_tenant_context(tenant_name TEXT)\r\nRETURNS void\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nAS $$\r\nBEGIN\r\n    PERFORM set_config('app.tenant_id', tenant_name, true);\r\nEND;\r\n$$;\r\n\r\n-- Create function to get current tenant\r\nCREATE OR REPLACE FUNCTION get_current_tenant()\r\nRETURNS TEXT\r\nLANGUAGE plpgsql\r\nSTABLE\r\nAS $$\r\nBEGIN\r\n    RETURN COALESCE(current_setting('app.tenant_id', true), 'lucerne');\r\nEND;\r\n$$;\r\n\r\n-- Update existing data to have lucerne tenant_id\r\nUPDATE employees SET tenant_id = 'lucerne' WHERE tenant_id IS NULL;\r\nUPDATE assessments SET tenant_id = 'lucerne' WHERE tenant_id IS NULL;\r\nUPDATE review_cycles SET tenant_id = 'lucerne' WHERE tenant_id IS NULL;\r\nUPDATE goals SET tenant_id = 'lucerne' WHERE tenant_id IS NULL;\r\nUPDATE feedback SET tenant_id = 'lucerne' WHERE tenant_id IS NULL;\r\nUPDATE notifications SET tenant_id = 'lucerne' WHERE tenant_id IS NULL;\r\n\r\n-- Create indexes for performance\r\nCREATE INDEX IF NOT EXISTS idx_employees_tenant_id ON employees(tenant_id);\r\nCREATE INDEX IF NOT EXISTS idx_assessments_tenant_id ON assessments(tenant_id);\r\nCREATE INDEX IF NOT EXISTS idx_review_cycles_tenant_id ON review_cycles(tenant_id);\r\nCREATE INDEX IF NOT EXISTS idx_goals_tenant_id ON goals(tenant_id);\r\nCREATE INDEX IF NOT EXISTS idx_feedback_tenant_id ON feedback(tenant_id);\r\nCREATE INDEX IF NOT EXISTS idx_notifications_tenant_id ON notifications(tenant_id);\r\n\r\n-- Create admin user for Lucerne (David Okonoski)\r\nINSERT INTO employees (\r\n    id, email, first_name, last_name, role, \r\n    is_active, tenant_id, created_at, updated_at\r\n) VALUES (\r\n    gen_random_uuid(),\r\n    'dokonoski@lucerneintl.com',\r\n    'David',\r\n    'Okonoski', \r\n    'super_admin',\r\n    true,\r\n    'lucerne',\r\n    NOW(),\r\n    NOW()\r\n) ON CONFLICT (email) DO UPDATE SET\r\n    role = 'super_admin',\r\n    tenant_id = 'lucerne',\r\n    is_active = true,\r\n    updated_at = NOW();\r\n\r\n-- Grant necessary permissions\r\nGRANT USAGE ON SCHEMA public TO anon, authenticated;\r\nGRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated;\r\nGRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated;\r\n\r\nCOMMENT ON TABLE tenants IS 'Multi-tenant configuration table';\r\nCOMMENT ON FUNCTION set_tenant_context IS 'Sets the current tenant context for RLS policies';\r\nCOMMENT ON FUNCTION get_current_tenant IS 'Returns the current tenant ID from context';",
    "path": "supabase/migrations/20250809000001_lucerne_tenant_setup.sql"
  }
}