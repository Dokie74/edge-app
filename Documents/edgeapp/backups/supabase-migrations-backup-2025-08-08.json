{
  "20250807124425_cleanup_obsolete_tables.sql": {
    "sql": "-- ========================================\n-- EDGE Application Database Cleanup Script\n-- Phase 1-3: Complete cleanup of obsolete tables\n-- ========================================\n-- Generated: 2025-08-07\n-- Purpose: Remove 8 confirmed obsolete tables that are no longer used\n--\n-- SAFETY MEASURES:\n-- 1. Creates backup/archive tables before deletion\n-- 2. Documents current row counts\n-- 3. Uses IF EXISTS clauses to prevent errors\n-- 4. Verifies no active dependencies\n\n-- ========================================\n-- PHASE 1: PRE-CLEANUP SAFETY MEASURES\n-- ========================================\n\n-- Document current state with row counts\nSELECT 'admin_backup' as table_name, COUNT(*) as row_count FROM admin_backup\nUNION ALL\nSELECT 'assessment_feedback' as table_name, COUNT(*) as row_count FROM assessment_feedback\nUNION ALL\nSELECT 'assessment_rocks' as table_name, COUNT(*) as row_count FROM assessment_rocks\nUNION ALL\nSELECT 'assessment_scorecard_metrics' as table_name, COUNT(*) as row_count FROM assessment_scorecard_metrics\nUNION ALL\nSELECT 'company_rocks' as table_name, COUNT(*) as row_count FROM company_rocks\nUNION ALL\nSELECT 'employee_development_goals' as table_name, COUNT(*) as row_count FROM employee_development_goals\nUNION ALL\nSELECT 'manager_employee_messages' as table_name, COUNT(*) as row_count FROM manager_employee_messages\nUNION ALL\nSELECT 'training_requests' as table_name, COUNT(*) as row_count FROM training_requests;\n\n-- Create archive tables (backup before deletion)\n-- Note: Archives will have _archive suffix and include cleanup timestamp\n\nCREATE TABLE IF NOT EXISTS admin_backup_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM admin_backup;\n\nCREATE TABLE IF NOT EXISTS assessment_feedback_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM assessment_feedback;\n\nCREATE TABLE IF NOT EXISTS assessment_rocks_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM assessment_rocks;\n\nCREATE TABLE IF NOT EXISTS assessment_scorecard_metrics_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM assessment_scorecard_metrics;\n\nCREATE TABLE IF NOT EXISTS company_rocks_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM company_rocks;\n\nCREATE TABLE IF NOT EXISTS employee_development_goals_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM employee_development_goals;\n\nCREATE TABLE IF NOT EXISTS manager_employee_messages_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM manager_employee_messages;\n\nCREATE TABLE IF NOT EXISTS training_requests_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM training_requests;\n\n-- Check for any foreign key dependencies that might prevent cleanup\nSELECT DISTINCT\n    tc.constraint_name,\n    tc.table_name,\n    kcu.column_name,\n    ccu.table_name AS foreign_table_name,\n    ccu.column_name AS foreign_column_name\nFROM information_schema.table_constraints AS tc\nJOIN information_schema.key_column_usage AS kcu\n    ON tc.constraint_name = kcu.constraint_name\nJOIN information_schema.constraint_column_usage AS ccu\n    ON ccu.constraint_name = tc.constraint_name\nWHERE tc.constraint_type = 'FOREIGN KEY'\n    AND (tc.table_name IN (\n        'admin_backup',\n        'assessment_feedback',\n        'assessment_rocks', \n        'assessment_scorecard_metrics',\n        'company_rocks',\n        'employee_development_goals',\n        'manager_employee_messages',\n        'training_requests'\n    ) \n    OR ccu.table_name IN (\n        'admin_backup',\n        'assessment_feedback',\n        'assessment_rocks',\n        'assessment_scorecard_metrics', \n        'company_rocks',\n        'employee_development_goals',\n        'manager_employee_messages',\n        'training_requests'\n    ));\n\n-- ========================================\n-- PHASE 2: EXECUTE CLEANUP \n-- ========================================\n\n-- Drop the 8 confirmed obsolete tables\n-- Using IF EXISTS to prevent errors if tables don't exist\n\nDROP TABLE IF EXISTS admin_backup CASCADE;\nDROP TABLE IF EXISTS assessment_feedback CASCADE;\nDROP TABLE IF EXISTS assessment_rocks CASCADE;\nDROP TABLE IF EXISTS assessment_scorecard_metrics CASCADE;\nDROP TABLE IF EXISTS company_rocks CASCADE;\nDROP TABLE IF EXISTS employee_development_goals CASCADE;\nDROP TABLE IF EXISTS manager_employee_messages CASCADE;\nDROP TABLE IF EXISTS training_requests CASCADE;",
    "path": "supabase/migrations/20250807124425_cleanup_obsolete_tables.sql"
  },
  "20250807150000_fix_critical_database_issues.sql": {
    "sql": "-- ================================================================\n-- EDGE App Critical Database Schema Fix\n-- Migration: 20250807150000_fix_critical_database_issues.sql\n-- Fixes 400 Bad Request errors by adding missing components\n-- ================================================================\n\n-- Enable UUID extension if not already enabled\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n-- ================================================================\n-- 1. CREATE DEPARTMENTS TABLE AND SUPPORTING STRUCTURES\n-- ================================================================\n\n-- Create departments table if it doesn't exist\nCREATE TABLE IF NOT EXISTS public.departments (\n    id integer NOT NULL,\n    name text NOT NULL,\n    code text,\n    description text,\n    created_at timestamp with time zone DEFAULT now(),\n    updated_at timestamp with time zone DEFAULT now(),\n    is_active boolean DEFAULT true\n);\n\n-- Add missing columns if they don't exist (for existing tables)\nDO $$\nBEGIN\n    -- Add is_active column\n    IF NOT EXISTS (\n        SELECT 1 FROM information_schema.columns \n        WHERE table_name = 'departments' \n        AND column_name = 'is_active' \n        AND table_schema = 'public'\n    ) THEN\n        ALTER TABLE public.departments ADD COLUMN is_active boolean DEFAULT true;\n    END IF;\n    \n    -- Add code column\n    IF NOT EXISTS (\n        SELECT 1 FROM information_schema.columns \n        WHERE table_name = 'departments' \n        AND column_name = 'code' \n        AND table_schema = 'public'\n    ) THEN\n        ALTER TABLE public.departments ADD COLUMN code text;\n    END IF;\n    \n    -- Set all existing departments as active and generate codes\n    UPDATE public.departments SET \n        is_active = COALESCE(is_active, true),\n        code = COALESCE(code, UPPER(LEFT(name, 3)))\n    WHERE is_active IS NULL OR code IS NULL;\nEND $$;\n\n-- Create sequence for departments\nCREATE SEQUENCE IF NOT EXISTS public.departments_id_seq\n    AS integer\n    START WITH 1\n    INCREMENT BY 1\n    NO MINVALUE\n    NO MAXVALUE\n    CACHE 1;\n\n-- Set sequence ownership and default\nALTER SEQUENCE public.departments_id_seq OWNED BY public.departments.id;\nALTER TABLE ONLY public.departments ALTER COLUMN id SET DEFAULT nextval('public.departments_id_seq'::regclass);\n\n-- Add primary key constraint if it doesn't exist\nDO $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'departments_pkey') THEN\n        ALTER TABLE ONLY public.departments ADD CONSTRAINT departments_pkey PRIMARY KEY (id);\n    END IF;\nEND $$;\n\n-- ================================================================\n-- 2. CREATE EMPLOYEE_DEPARTMENTS TABLE AND SUPPORTING STRUCTURES\n-- ================================================================\n\n-- Create employee_departments table if it doesn't exist\nCREATE TABLE IF NOT EXISTS public.employee_departments (\n    id integer NOT NULL,\n    employee_id uuid,\n    department_id integer,\n    created_at timestamp with time zone DEFAULT now(),\n    is_primary boolean DEFAULT false,\n    assigned_by uuid\n);\n\n-- Create sequence for employee_departments\nCREATE SEQUENCE IF NOT EXISTS public.employee_departments_id_seq\n    AS integer\n    START WITH 1\n    INCREMENT BY 1\n    NO MINVALUE\n    NO MAXVALUE\n    CACHE 1;\n\n-- Set sequence ownership and default\nALTER SEQUENCE public.employee_departments_id_seq OWNED BY public.employee_departments.id;\nALTER TABLE ONLY public.employee_departments ALTER COLUMN id SET DEFAULT nextval('public.employee_departments_id_seq'::regclass);\n\n-- Add primary key constraint if it doesn't exist\nDO $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'employee_departments_pkey') THEN\n        ALTER TABLE ONLY public.employee_departments ADD CONSTRAINT employee_departments_pkey PRIMARY KEY (id);\n    END IF;\nEND $$;\n\n-- Add foreign key constraints if they don't exist\nDO $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'employee_departments_employee_id_fkey') THEN\n        ALTER TABLE ONLY public.employee_departments ADD CONSTRAINT employee_departments_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES public.employees(id);\n    END IF;\nEND $$;\n\nDO $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'employee_departments_department_id_fkey') THEN\n        ALTER TABLE ONLY public.employee_departments ADD CONSTRAINT employee_departments_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.departments(id);\n    END IF;\nEND $$;\n\n-- ================================================================\n-- 3. ENABLE ROW LEVEL SECURITY AND CREATE POLICIES\n-- ================================================================\n\n-- Enable RLS on both tables\nALTER TABLE public.departments ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.employee_departments ENABLE ROW LEVEL SECURITY;\n\n-- Create RLS policies for departments table\nDROP POLICY IF EXISTS \"Everyone can view departments\" ON public.departments;\nCREATE POLICY \"Everyone can view departments\" ON public.departments FOR SELECT USING (true);\n\nDROP POLICY IF EXISTS \"Only admins can modify departments\" ON public.departments;\nCREATE POLICY \"Only admins can modify departments\" ON public.departments USING ((EXISTS ( SELECT 1\n   FROM public.employees\n  WHERE ((employees.user_id = auth.uid()) AND (employees.role = 'admin'::text)))));\n\nDROP POLICY IF EXISTS departments_select_all ON public.departments;\nCREATE POLICY departments_select_all ON public.departments FOR SELECT TO authenticated USING (true);\n\n-- Create RLS policies for employee_departments table\nDROP POLICY IF EXISTS \"Users can view department assignments\" ON public.employee_departments;\nCREATE POLICY \"Users can view department assignments\" ON public.employee_departments FOR SELECT USING (((employee_id IN ( SELECT employees.id\n   FROM public.employees\n  WHERE (employees.user_id = auth.uid()))) OR (EXISTS ( SELECT 1\n   FROM (public.employees e1\n     JOIN public.employees e2 ON ((e1.id = e2.manager_id)))\n  WHERE ((e1.user_id = auth.uid()) AND (e2.id = employee_departments.employee_id)))) OR (EXISTS ( SELECT 1\n   FROM public.employees\n  WHERE ((employees.user_id = auth.uid()) AND (employees.role = 'admin'::text))))));\n\nDROP POLICY IF EXISTS \"Only admins can modify department assignments\" ON public.employee_departments;\nCREATE POLICY \"Only admins can modify department assignments\" ON public.employee_departments USING ((EXISTS ( SELECT 1\n   FROM public.employees\n  WHERE ((employees.user_id = auth.uid()) AND (employees.role = 'admin'::text)))));\n\nDROP POLICY IF EXISTS employee_departments_select_own ON public.employee_departments;\nCREATE POLICY employee_departments_select_own ON public.employee_departments FOR SELECT TO authenticated USING (((employee_id IN ( SELECT employees.id\n   FROM public.employees\n  WHERE ((employees.user_id = auth.uid()) AND (employees.is_active = true)))) OR (employee_id IN ( SELECT e.id\n   FROM public.employees e\n  WHERE (e.manager_id IN ( SELECT employees.id\n           FROM public.employees\n          WHERE ((employees.user_id = auth.uid()) AND (employees.is_active = true)))))) OR (EXISTS ( SELECT 1\n   FROM public.employees\n  WHERE ((employees.user_id = auth.uid()) AND (employees.role = 'admin'::text) AND (employees.is_active = true))))));\n\n-- ================================================================\n-- 4. INSERT DEPARTMENT DATA\n-- ================================================================\n\n-- Set the sequence value to start from 11 (based on backup data)\nSELECT pg_catalog.setval('public.departments_id_seq', 30, true);\n\n-- Insert departments if they don't already exist\nINSERT INTO public.departments (id, name, code, description, created_at, updated_at, is_active) VALUES\n(11, 'Accounting', 'ACC', 'Financial operations and accounting', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(12, 'Purchasing', 'PUR', 'Procurement and vendor management', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(13, 'Engineering', 'ENG', 'Product development and engineering', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(14, 'Executive', 'EXE', 'Executive leadership and strategy', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(15, 'Quality', 'QUA', 'Quality assurance and control', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(16, 'Production', 'PRO', 'Manufacturing and production', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(17, 'Machining', 'MAC', 'Machining operations', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(18, 'Program Management', 'PGM', 'Program and project management', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(19, 'Sales', 'SAL', 'Sales and customer relations', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(20, 'General', 'GEN', 'General/Unassigned employees', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true)\nON CONFLICT (id) DO NOTHING;\n\n-- Set the employee_departments sequence value\nSELECT pg_catalog.setval('public.employee_departments_id_seq', 15, true);\n\n-- ================================================================\n-- 5. CREATE get_pending_admin_approvals FUNCTION\n-- ================================================================\n\nCREATE OR REPLACE FUNCTION public.get_pending_admin_approvals() \nRETURNS TABLE(\n    assessment_id bigint, \n    employee_name text, \n    employee_email text, \n    manager_name text, \n    manager_email text, \n    review_cycle_name text, \n    submitted_date timestamp with time zone, \n    due_date date, \n    manager_performance_rating text, \n    manager_summary_comments text\n)\nLANGUAGE plpgsql SECURITY DEFINER\nAS $$\nDECLARE\n    v_user_role text;\n    v_current_employee_id uuid;\nBEGIN\n    -- Get current user's role from employees table (not auth.users)\n    SELECT role INTO v_user_role \n    FROM public.employees \n    WHERE user_id = auth.uid() \n    AND is_active = true;\n    \n    -- Only admins can access this function\n    IF v_user_role != 'admin' THEN\n        RAISE EXCEPTION 'Access denied: Admin role required';\n    END IF;\n\n    RETURN QUERY\n    SELECT \n        a.id as assessment_id,\n        e.name as employee_name,\n        e.email as employee_email,\n        m.name as manager_name,\n        m.email as manager_email,\n        rc.name as review_cycle_name,\n        a.manager_reviewed_at as submitted_date,\n        a.due_date,\n        a.manager_performance_rating,\n        a.manager_summary_comments\n    FROM assessments a\n    JOIN employees e ON a.employee_id = e.id\n    JOIN employees m ON e.manager_id = m.id  -- Get the manager who submitted the review\n    JOIN review_cycles rc ON a.review_cycle_id = rc.id\n    WHERE a.self_assessment_status = 'pending_admin_approval'\n    AND rc.status = 'active'\n    ORDER BY a.manager_reviewed_at DESC;\nEND;\n$$;\n\n-- Grant execute permission to authenticated users\nGRANT EXECUTE ON FUNCTION public.get_pending_admin_approvals() TO authenticated;\n\n-- ================================================================\n-- 6. CREATE SUPPORTING HELPER FUNCTIONS\n-- ================================================================\n\n-- Function to get employee primary department\nCREATE OR REPLACE FUNCTION public.get_employee_primary_department(emp_id uuid) \nRETURNS TABLE(dept_id integer, dept_name text)\nLANGUAGE plpgsql SECURITY DEFINER\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        d.id as dept_id,\n        d.name as dept_name\n    FROM departments d\n    JOIN employee_departments ed ON d.id = ed.department_id\n    WHERE ed.employee_id = emp_id \n    AND ed.is_primary = true\n    LIMIT 1;\n    \n    -- If no primary department found, return default\n    IF NOT FOUND THEN\n        RETURN QUERY\n        SELECT \n            20 as dept_id,\n            'General' as dept_name;\n    END IF;\nEND;\n$$;\n\n-- Grant execute permission\nGRANT EXECUTE ON FUNCTION public.get_employee_primary_department(uuid) TO authenticated;\n\n-- Function to assign primary department\nCREATE OR REPLACE FUNCTION public.assign_primary_department(emp_id uuid, dept_id integer, assigned_by_id uuid DEFAULT NULL) \nRETURNS boolean\nLANGUAGE plpgsql SECURITY DEFINER\nAS $$\nBEGIN\n    -- Remove existing primary department assignments for this employee\n    UPDATE employee_departments \n    SET is_primary = false \n    WHERE employee_id = emp_id AND is_primary = true;\n    \n    -- Insert or update the new primary department assignment\n    INSERT INTO public.employee_departments (employee_id, department_id, is_primary, assigned_by)\n    VALUES (emp_id, dept_id, true, assigned_by_id)\n    ON CONFLICT (employee_id, department_id) \n    DO UPDATE SET is_primary = true, assigned_by = assigned_by_id;\n    \n    -- Update the backward compatibility column if employees table has department column\n    UPDATE public.employees \n    SET department = (SELECT name FROM public.departments WHERE id = dept_id)\n    WHERE id = emp_id AND EXISTS (\n        SELECT 1 FROM information_schema.columns \n        WHERE table_name = 'employees' \n        AND column_name = 'department' \n        AND table_schema = 'public'\n    );\n    \n    RETURN true;\nEND;\n$$;\n\n-- Grant execute permission\nGRANT EXECUTE ON FUNCTION public.assign_primary_department(uuid, integer, uuid) TO authenticated;\n\n-- ================================================================\n-- 7. FINAL VERIFICATION AND COMMENTS\n-- ================================================================\n\nCOMMENT ON TABLE public.departments IS 'Department structure for organizational hierarchy';\nCOMMENT ON TABLE public.employee_departments IS 'Junction table for employee-department assignments with primary department support';\nCOMMENT ON FUNCTION public.get_pending_admin_approvals() IS 'Returns assessments pending admin approval for review workflow';\nCOMMENT ON FUNCTION public.get_employee_primary_department(uuid) IS 'Gets the primary department for an employee';\nCOMMENT ON FUNCTION public.assign_primary_department(uuid, integer, uuid) IS 'Assigns a primary department to an employee';\n\n-- Migration complete\nSELECT 'Migration 20250807150000_fix_critical_database_issues completed successfully' as status;",
    "path": "supabase/migrations/20250807150000_fix_critical_database_issues.sql"
  },
  "20250807160000_add_delete_feedback_function.sql": {
    "sql": "-- ================================================================\n-- EDGE App Admin Feedback Management\n-- Migration: 20250807160000_add_delete_feedback_function.sql\n-- Purpose: Allow admins to delete inappropriate feedback from the feedback wall\n-- ================================================================\n\n-- Drop function if it exists to avoid conflicts\nDROP FUNCTION IF EXISTS public.delete_feedback(bigint);\n\n-- Function to delete feedback (admin only)\nCREATE OR REPLACE FUNCTION public.delete_feedback(\n    p_feedback_id bigint\n)\nRETURNS json AS $$\nDECLARE\n    current_user_role text;\n    feedback_exists boolean;\n    current_user_active boolean;\nBEGIN\n    -- Get current user role and active status from employees table\n    SELECT role, is_active INTO current_user_role, current_user_active\n    FROM public.employees \n    WHERE user_id = auth.uid();\n    \n    -- Check if user exists and is active\n    IF current_user_role IS NULL OR NOT current_user_active THEN\n        RETURN json_build_object('error', 'User not found or inactive.');\n    END IF;\n    \n    -- Check if user is admin\n    IF current_user_role != 'admin' THEN\n        RETURN json_build_object('error', 'Access denied. Only admins can delete feedback.');\n    END IF;\n    \n    -- Check if feedback exists\n    SELECT EXISTS(\n        SELECT 1 FROM public.feedback \n        WHERE id = p_feedback_id\n    ) INTO feedback_exists;\n    \n    IF NOT feedback_exists THEN\n        RETURN json_build_object('error', 'Feedback not found.');\n    END IF;\n    \n    -- Delete the feedback\n    DELETE FROM public.feedback \n    WHERE id = p_feedback_id;\n    \n    -- Verify deletion was successful\n    IF NOT FOUND THEN\n        RETURN json_build_object('error', 'Failed to delete feedback.');\n    END IF;\n    \n    RETURN json_build_object(\n        'success', true,\n        'message', 'Feedback deleted successfully',\n        'feedback_id', p_feedback_id\n    );\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Grant execute permission to authenticated users\nGRANT EXECUTE ON FUNCTION public.delete_feedback(bigint) TO authenticated;\n\n-- Add comment for documentation\nCOMMENT ON FUNCTION public.delete_feedback(bigint) IS 'Allows admin users to delete inappropriate feedback from the feedback wall';\n\n-- Migration complete\nSELECT 'Migration 20250807160000_add_delete_feedback_function completed successfully' as status;",
    "path": "supabase/migrations/20250807160000_add_delete_feedback_function.sql"
  }
}