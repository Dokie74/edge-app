{
  "20250807124425_cleanup_obsolete_tables.sql": {
    "sql": "-- ========================================\n-- EDGE Application Database Cleanup Script\n-- Phase 1-3: Complete cleanup of obsolete tables\n-- ========================================\n-- Generated: 2025-08-07\n-- Purpose: Remove 8 confirmed obsolete tables that are no longer used\n--\n-- SAFETY MEASURES:\n-- 1. Creates backup/archive tables before deletion\n-- 2. Documents current row counts\n-- 3. Uses IF EXISTS clauses to prevent errors\n-- 4. Verifies no active dependencies\n\n-- ========================================\n-- PHASE 1: PRE-CLEANUP SAFETY MEASURES\n-- ========================================\n\n-- Document current state with row counts\nSELECT 'admin_backup' as table_name, COUNT(*) as row_count FROM admin_backup\nUNION ALL\nSELECT 'assessment_feedback' as table_name, COUNT(*) as row_count FROM assessment_feedback\nUNION ALL\nSELECT 'assessment_rocks' as table_name, COUNT(*) as row_count FROM assessment_rocks\nUNION ALL\nSELECT 'assessment_scorecard_metrics' as table_name, COUNT(*) as row_count FROM assessment_scorecard_metrics\nUNION ALL\nSELECT 'company_rocks' as table_name, COUNT(*) as row_count FROM company_rocks\nUNION ALL\nSELECT 'employee_development_goals' as table_name, COUNT(*) as row_count FROM employee_development_goals\nUNION ALL\nSELECT 'manager_employee_messages' as table_name, COUNT(*) as row_count FROM manager_employee_messages\nUNION ALL\nSELECT 'training_requests' as table_name, COUNT(*) as row_count FROM training_requests;\n\n-- Create archive tables (backup before deletion)\n-- Note: Archives will have _archive suffix and include cleanup timestamp\n\nCREATE TABLE IF NOT EXISTS admin_backup_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM admin_backup;\n\nCREATE TABLE IF NOT EXISTS assessment_feedback_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM assessment_feedback;\n\nCREATE TABLE IF NOT EXISTS assessment_rocks_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM assessment_rocks;\n\nCREATE TABLE IF NOT EXISTS assessment_scorecard_metrics_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM assessment_scorecard_metrics;\n\nCREATE TABLE IF NOT EXISTS company_rocks_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM company_rocks;\n\nCREATE TABLE IF NOT EXISTS employee_development_goals_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM employee_development_goals;\n\nCREATE TABLE IF NOT EXISTS manager_employee_messages_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM manager_employee_messages;\n\nCREATE TABLE IF NOT EXISTS training_requests_archive AS \nSELECT *, NOW() as archived_at, 'database_cleanup_2025_08_07' as cleanup_batch\nFROM training_requests;\n\n-- Check for any foreign key dependencies that might prevent cleanup\nSELECT DISTINCT\n    tc.constraint_name,\n    tc.table_name,\n    kcu.column_name,\n    ccu.table_name AS foreign_table_name,\n    ccu.column_name AS foreign_column_name\nFROM information_schema.table_constraints AS tc\nJOIN information_schema.key_column_usage AS kcu\n    ON tc.constraint_name = kcu.constraint_name\nJOIN information_schema.constraint_column_usage AS ccu\n    ON ccu.constraint_name = tc.constraint_name\nWHERE tc.constraint_type = 'FOREIGN KEY'\n    AND (tc.table_name IN (\n        'admin_backup',\n        'assessment_feedback',\n        'assessment_rocks', \n        'assessment_scorecard_metrics',\n        'company_rocks',\n        'employee_development_goals',\n        'manager_employee_messages',\n        'training_requests'\n    ) \n    OR ccu.table_name IN (\n        'admin_backup',\n        'assessment_feedback',\n        'assessment_rocks',\n        'assessment_scorecard_metrics', \n        'company_rocks',\n        'employee_development_goals',\n        'manager_employee_messages',\n        'training_requests'\n    ));\n\n-- ========================================\n-- PHASE 2: EXECUTE CLEANUP \n-- ========================================\n\n-- Drop the 8 confirmed obsolete tables\n-- Using IF EXISTS to prevent errors if tables don't exist\n\nDROP TABLE IF EXISTS admin_backup CASCADE;\nDROP TABLE IF EXISTS assessment_feedback CASCADE;\nDROP TABLE IF EXISTS assessment_rocks CASCADE;\nDROP TABLE IF EXISTS assessment_scorecard_metrics CASCADE;\nDROP TABLE IF EXISTS company_rocks CASCADE;\nDROP TABLE IF EXISTS employee_development_goals CASCADE;\nDROP TABLE IF EXISTS manager_employee_messages CASCADE;\nDROP TABLE IF EXISTS training_requests CASCADE;",
    "path": "supabase/migrations/20250807124425_cleanup_obsolete_tables.sql"
  },
  "20250807150000_fix_critical_database_issues.sql": {
    "sql": "-- ================================================================\n-- EDGE App Critical Database Schema Fix\n-- Migration: 20250807150000_fix_critical_database_issues.sql\n-- Fixes 400 Bad Request errors by adding missing components\n-- ================================================================\n\n-- Enable UUID extension if not already enabled\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n-- ================================================================\n-- 1. CREATE DEPARTMENTS TABLE AND SUPPORTING STRUCTURES\n-- ================================================================\n\n-- Create departments table if it doesn't exist\nCREATE TABLE IF NOT EXISTS public.departments (\n    id integer NOT NULL,\n    name text NOT NULL,\n    code text,\n    description text,\n    created_at timestamp with time zone DEFAULT now(),\n    updated_at timestamp with time zone DEFAULT now(),\n    is_active boolean DEFAULT true\n);\n\n-- Add missing columns if they don't exist (for existing tables)\nDO $$\nBEGIN\n    -- Add is_active column\n    IF NOT EXISTS (\n        SELECT 1 FROM information_schema.columns \n        WHERE table_name = 'departments' \n        AND column_name = 'is_active' \n        AND table_schema = 'public'\n    ) THEN\n        ALTER TABLE public.departments ADD COLUMN is_active boolean DEFAULT true;\n    END IF;\n    \n    -- Add code column\n    IF NOT EXISTS (\n        SELECT 1 FROM information_schema.columns \n        WHERE table_name = 'departments' \n        AND column_name = 'code' \n        AND table_schema = 'public'\n    ) THEN\n        ALTER TABLE public.departments ADD COLUMN code text;\n    END IF;\n    \n    -- Set all existing departments as active and generate codes\n    UPDATE public.departments SET \n        is_active = COALESCE(is_active, true),\n        code = COALESCE(code, UPPER(LEFT(name, 3)))\n    WHERE is_active IS NULL OR code IS NULL;\nEND $$;\n\n-- Create sequence for departments\nCREATE SEQUENCE IF NOT EXISTS public.departments_id_seq\n    AS integer\n    START WITH 1\n    INCREMENT BY 1\n    NO MINVALUE\n    NO MAXVALUE\n    CACHE 1;\n\n-- Set sequence ownership and default\nALTER SEQUENCE public.departments_id_seq OWNED BY public.departments.id;\nALTER TABLE ONLY public.departments ALTER COLUMN id SET DEFAULT nextval('public.departments_id_seq'::regclass);\n\n-- Add primary key constraint if it doesn't exist\nDO $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'departments_pkey') THEN\n        ALTER TABLE ONLY public.departments ADD CONSTRAINT departments_pkey PRIMARY KEY (id);\n    END IF;\nEND $$;\n\n-- ================================================================\n-- 2. CREATE EMPLOYEE_DEPARTMENTS TABLE AND SUPPORTING STRUCTURES\n-- ================================================================\n\n-- Create employee_departments table if it doesn't exist\nCREATE TABLE IF NOT EXISTS public.employee_departments (\n    id integer NOT NULL,\n    employee_id uuid,\n    department_id integer,\n    created_at timestamp with time zone DEFAULT now(),\n    is_primary boolean DEFAULT false,\n    assigned_by uuid\n);\n\n-- Create sequence for employee_departments\nCREATE SEQUENCE IF NOT EXISTS public.employee_departments_id_seq\n    AS integer\n    START WITH 1\n    INCREMENT BY 1\n    NO MINVALUE\n    NO MAXVALUE\n    CACHE 1;\n\n-- Set sequence ownership and default\nALTER SEQUENCE public.employee_departments_id_seq OWNED BY public.employee_departments.id;\nALTER TABLE ONLY public.employee_departments ALTER COLUMN id SET DEFAULT nextval('public.employee_departments_id_seq'::regclass);\n\n-- Add primary key constraint if it doesn't exist\nDO $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'employee_departments_pkey') THEN\n        ALTER TABLE ONLY public.employee_departments ADD CONSTRAINT employee_departments_pkey PRIMARY KEY (id);\n    END IF;\nEND $$;\n\n-- Add foreign key constraints if they don't exist\nDO $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'employee_departments_employee_id_fkey') THEN\n        ALTER TABLE ONLY public.employee_departments ADD CONSTRAINT employee_departments_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES public.employees(id);\n    END IF;\nEND $$;\n\nDO $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'employee_departments_department_id_fkey') THEN\n        ALTER TABLE ONLY public.employee_departments ADD CONSTRAINT employee_departments_department_id_fkey FOREIGN KEY (department_id) REFERENCES public.departments(id);\n    END IF;\nEND $$;\n\n-- ================================================================\n-- 3. ENABLE ROW LEVEL SECURITY AND CREATE POLICIES\n-- ================================================================\n\n-- Enable RLS on both tables\nALTER TABLE public.departments ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.employee_departments ENABLE ROW LEVEL SECURITY;\n\n-- Create RLS policies for departments table\nDROP POLICY IF EXISTS \"Everyone can view departments\" ON public.departments;\nCREATE POLICY \"Everyone can view departments\" ON public.departments FOR SELECT USING (true);\n\nDROP POLICY IF EXISTS \"Only admins can modify departments\" ON public.departments;\nCREATE POLICY \"Only admins can modify departments\" ON public.departments USING ((EXISTS ( SELECT 1\n   FROM public.employees\n  WHERE ((employees.user_id = auth.uid()) AND (employees.role = 'admin'::text)))));\n\nDROP POLICY IF EXISTS departments_select_all ON public.departments;\nCREATE POLICY departments_select_all ON public.departments FOR SELECT TO authenticated USING (true);\n\n-- Create RLS policies for employee_departments table\nDROP POLICY IF EXISTS \"Users can view department assignments\" ON public.employee_departments;\nCREATE POLICY \"Users can view department assignments\" ON public.employee_departments FOR SELECT USING (((employee_id IN ( SELECT employees.id\n   FROM public.employees\n  WHERE (employees.user_id = auth.uid()))) OR (EXISTS ( SELECT 1\n   FROM (public.employees e1\n     JOIN public.employees e2 ON ((e1.id = e2.manager_id)))\n  WHERE ((e1.user_id = auth.uid()) AND (e2.id = employee_departments.employee_id)))) OR (EXISTS ( SELECT 1\n   FROM public.employees\n  WHERE ((employees.user_id = auth.uid()) AND (employees.role = 'admin'::text))))));\n\nDROP POLICY IF EXISTS \"Only admins can modify department assignments\" ON public.employee_departments;\nCREATE POLICY \"Only admins can modify department assignments\" ON public.employee_departments USING ((EXISTS ( SELECT 1\n   FROM public.employees\n  WHERE ((employees.user_id = auth.uid()) AND (employees.role = 'admin'::text)))));\n\nDROP POLICY IF EXISTS employee_departments_select_own ON public.employee_departments;\nCREATE POLICY employee_departments_select_own ON public.employee_departments FOR SELECT TO authenticated USING (((employee_id IN ( SELECT employees.id\n   FROM public.employees\n  WHERE ((employees.user_id = auth.uid()) AND (employees.is_active = true)))) OR (employee_id IN ( SELECT e.id\n   FROM public.employees e\n  WHERE (e.manager_id IN ( SELECT employees.id\n           FROM public.employees\n          WHERE ((employees.user_id = auth.uid()) AND (employees.is_active = true)))))) OR (EXISTS ( SELECT 1\n   FROM public.employees\n  WHERE ((employees.user_id = auth.uid()) AND (employees.role = 'admin'::text) AND (employees.is_active = true))))));\n\n-- ================================================================\n-- 4. INSERT DEPARTMENT DATA\n-- ================================================================\n\n-- Set the sequence value to start from 11 (based on backup data)\nSELECT pg_catalog.setval('public.departments_id_seq', 30, true);\n\n-- Insert departments if they don't already exist\nINSERT INTO public.departments (id, name, code, description, created_at, updated_at, is_active) VALUES\n(11, 'Accounting', 'ACC', 'Financial operations and accounting', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(12, 'Purchasing', 'PUR', 'Procurement and vendor management', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(13, 'Engineering', 'ENG', 'Product development and engineering', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(14, 'Executive', 'EXE', 'Executive leadership and strategy', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(15, 'Quality', 'QUA', 'Quality assurance and control', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(16, 'Production', 'PRO', 'Manufacturing and production', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(17, 'Machining', 'MAC', 'Machining operations', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(18, 'Program Management', 'PGM', 'Program and project management', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(19, 'Sales', 'SAL', 'Sales and customer relations', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true),\n(20, 'General', 'GEN', 'General/Unassigned employees', '2025-07-30 13:03:31.66752+00', '2025-07-30 13:03:31.66752+00', true)\nON CONFLICT (id) DO NOTHING;\n\n-- Set the employee_departments sequence value\nSELECT pg_catalog.setval('public.employee_departments_id_seq', 15, true);\n\n-- ================================================================\n-- 5. CREATE get_pending_admin_approvals FUNCTION\n-- ================================================================\n\nCREATE OR REPLACE FUNCTION public.get_pending_admin_approvals() \nRETURNS TABLE(\n    assessment_id bigint, \n    employee_name text, \n    employee_email text, \n    manager_name text, \n    manager_email text, \n    review_cycle_name text, \n    submitted_date timestamp with time zone, \n    due_date date, \n    manager_performance_rating text, \n    manager_summary_comments text\n)\nLANGUAGE plpgsql SECURITY DEFINER\nAS $$\nDECLARE\n    v_user_role text;\n    v_current_employee_id uuid;\nBEGIN\n    -- Get current user's role from employees table (not auth.users)\n    SELECT role INTO v_user_role \n    FROM public.employees \n    WHERE user_id = auth.uid() \n    AND is_active = true;\n    \n    -- Only admins can access this function\n    IF v_user_role != 'admin' THEN\n        RAISE EXCEPTION 'Access denied: Admin role required';\n    END IF;\n\n    RETURN QUERY\n    SELECT \n        a.id as assessment_id,\n        e.name as employee_name,\n        e.email as employee_email,\n        m.name as manager_name,\n        m.email as manager_email,\n        rc.name as review_cycle_name,\n        a.manager_reviewed_at as submitted_date,\n        a.due_date,\n        a.manager_performance_rating,\n        a.manager_summary_comments\n    FROM assessments a\n    JOIN employees e ON a.employee_id = e.id\n    JOIN employees m ON e.manager_id = m.id  -- Get the manager who submitted the review\n    JOIN review_cycles rc ON a.review_cycle_id = rc.id\n    WHERE a.self_assessment_status = 'pending_admin_approval'\n    AND rc.status = 'active'\n    ORDER BY a.manager_reviewed_at DESC;\nEND;\n$$;\n\n-- Grant execute permission to authenticated users\nGRANT EXECUTE ON FUNCTION public.get_pending_admin_approvals() TO authenticated;\n\n-- ================================================================\n-- 6. CREATE SUPPORTING HELPER FUNCTIONS\n-- ================================================================\n\n-- Function to get employee primary department\nCREATE OR REPLACE FUNCTION public.get_employee_primary_department(emp_id uuid) \nRETURNS TABLE(dept_id integer, dept_name text)\nLANGUAGE plpgsql SECURITY DEFINER\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        d.id as dept_id,\n        d.name as dept_name\n    FROM departments d\n    JOIN employee_departments ed ON d.id = ed.department_id\n    WHERE ed.employee_id = emp_id \n    AND ed.is_primary = true\n    LIMIT 1;\n    \n    -- If no primary department found, return default\n    IF NOT FOUND THEN\n        RETURN QUERY\n        SELECT \n            20 as dept_id,\n            'General' as dept_name;\n    END IF;\nEND;\n$$;\n\n-- Grant execute permission\nGRANT EXECUTE ON FUNCTION public.get_employee_primary_department(uuid) TO authenticated;\n\n-- Function to assign primary department\nCREATE OR REPLACE FUNCTION public.assign_primary_department(emp_id uuid, dept_id integer, assigned_by_id uuid DEFAULT NULL) \nRETURNS boolean\nLANGUAGE plpgsql SECURITY DEFINER\nAS $$\nBEGIN\n    -- Remove existing primary department assignments for this employee\n    UPDATE employee_departments \n    SET is_primary = false \n    WHERE employee_id = emp_id AND is_primary = true;\n    \n    -- Insert or update the new primary department assignment\n    INSERT INTO public.employee_departments (employee_id, department_id, is_primary, assigned_by)\n    VALUES (emp_id, dept_id, true, assigned_by_id)\n    ON CONFLICT (employee_id, department_id) \n    DO UPDATE SET is_primary = true, assigned_by = assigned_by_id;\n    \n    -- Update the backward compatibility column if employees table has department column\n    UPDATE public.employees \n    SET department = (SELECT name FROM public.departments WHERE id = dept_id)\n    WHERE id = emp_id AND EXISTS (\n        SELECT 1 FROM information_schema.columns \n        WHERE table_name = 'employees' \n        AND column_name = 'department' \n        AND table_schema = 'public'\n    );\n    \n    RETURN true;\nEND;\n$$;\n\n-- Grant execute permission\nGRANT EXECUTE ON FUNCTION public.assign_primary_department(uuid, integer, uuid) TO authenticated;\n\n-- ================================================================\n-- 7. FINAL VERIFICATION AND COMMENTS\n-- ================================================================\n\nCOMMENT ON TABLE public.departments IS 'Department structure for organizational hierarchy';\nCOMMENT ON TABLE public.employee_departments IS 'Junction table for employee-department assignments with primary department support';\nCOMMENT ON FUNCTION public.get_pending_admin_approvals() IS 'Returns assessments pending admin approval for review workflow';\nCOMMENT ON FUNCTION public.get_employee_primary_department(uuid) IS 'Gets the primary department for an employee';\nCOMMENT ON FUNCTION public.assign_primary_department(uuid, integer, uuid) IS 'Assigns a primary department to an employee';\n\n-- Migration complete\nSELECT 'Migration 20250807150000_fix_critical_database_issues completed successfully' as status;",
    "path": "supabase/migrations/20250807150000_fix_critical_database_issues.sql"
  },
  "20250807160000_add_delete_feedback_function.sql": {
    "sql": "-- ================================================================\n-- EDGE App Admin Feedback Management\n-- Migration: 20250807160000_add_delete_feedback_function.sql\n-- Purpose: Allow admins to delete inappropriate feedback from the feedback wall\n-- ================================================================\n\n-- Drop function if it exists to avoid conflicts\nDROP FUNCTION IF EXISTS public.delete_feedback(bigint);\n\n-- Function to delete feedback (admin only)\nCREATE OR REPLACE FUNCTION public.delete_feedback(\n    p_feedback_id bigint\n)\nRETURNS json AS $$\nDECLARE\n    current_user_role text;\n    feedback_exists boolean;\n    current_user_active boolean;\nBEGIN\n    -- Get current user role and active status from employees table\n    SELECT role, is_active INTO current_user_role, current_user_active\n    FROM public.employees \n    WHERE user_id = auth.uid();\n    \n    -- Check if user exists and is active\n    IF current_user_role IS NULL OR NOT current_user_active THEN\n        RETURN json_build_object('error', 'User not found or inactive.');\n    END IF;\n    \n    -- Check if user is admin\n    IF current_user_role != 'admin' THEN\n        RETURN json_build_object('error', 'Access denied. Only admins can delete feedback.');\n    END IF;\n    \n    -- Check if feedback exists\n    SELECT EXISTS(\n        SELECT 1 FROM public.feedback \n        WHERE id = p_feedback_id\n    ) INTO feedback_exists;\n    \n    IF NOT feedback_exists THEN\n        RETURN json_build_object('error', 'Feedback not found.');\n    END IF;\n    \n    -- Delete the feedback\n    DELETE FROM public.feedback \n    WHERE id = p_feedback_id;\n    \n    -- Verify deletion was successful\n    IF NOT FOUND THEN\n        RETURN json_build_object('error', 'Failed to delete feedback.');\n    END IF;\n    \n    RETURN json_build_object(\n        'success', true,\n        'message', 'Feedback deleted successfully',\n        'feedback_id', p_feedback_id\n    );\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Grant execute permission to authenticated users\nGRANT EXECUTE ON FUNCTION public.delete_feedback(bigint) TO authenticated;\n\n-- Add comment for documentation\nCOMMENT ON FUNCTION public.delete_feedback(bigint) IS 'Allows admin users to delete inappropriate feedback from the feedback wall';\n\n-- Migration complete\nSELECT 'Migration 20250807160000_add_delete_feedback_function completed successfully' as status;",
    "path": "supabase/migrations/20250807160000_add_delete_feedback_function.sql"
  },
  "20250808000001_enforce_unique_user_id.sql": {
    "sql": "-- Migration: Enforce 1:1 employeeâ†”auth mapping\n-- Description: Add unique constraint on employees.user_id to prevent duplicate auth mappings\n-- Issue: Multiple employee records could reference the same auth user, breaking RLS logic\n\n-- Step 1: Check for and resolve any existing duplicates (safety check)\n-- This will identify any duplicate user_id values that would prevent the unique constraint\nDO $$\nDECLARE\n    duplicate_count INTEGER;\n    duplicate_record RECORD;\nBEGIN\n    -- Check for existing duplicates\n    SELECT COUNT(*) INTO duplicate_count\n    FROM (\n        SELECT user_id \n        FROM public.employees \n        WHERE user_id IS NOT NULL\n        GROUP BY user_id \n        HAVING COUNT(*) > 1\n    ) dups;\n    \n    IF duplicate_count > 0 THEN\n        RAISE NOTICE 'Found % duplicate user_id values in employees table', duplicate_count;\n        \n        -- List the duplicates for manual review\n        FOR duplicate_record IN \n            SELECT user_id, string_agg(id::text || ':' || email, ', ') as records\n            FROM public.employees \n            WHERE user_id IS NOT NULL\n            GROUP BY user_id \n            HAVING COUNT(*) > 1\n        LOOP\n            RAISE NOTICE 'Duplicate user_id %: records %', duplicate_record.user_id, duplicate_record.records;\n        END LOOP;\n        \n        RAISE EXCEPTION 'Cannot add unique constraint: duplicate user_id values exist. Please resolve manually.';\n    END IF;\n    \n    RAISE NOTICE 'No duplicates found. Safe to proceed with unique constraint.';\nEND $$;\n\n-- Step 2: Add the unique constraint\n-- This ensures each auth.users.id can only be referenced by one employee record\nCREATE UNIQUE INDEX IF NOT EXISTS uq_employees_user_id \nON public.employees(user_id) \nWHERE user_id IS NOT NULL;\n\n-- Step 3: Add a comment explaining the constraint\nCOMMENT ON INDEX uq_employees_user_id IS \n'Ensures 1:1 mapping between auth.users and employees. Critical for RLS policy correctness.';\n\n-- Verification query (will be logged in migration output)\nSELECT \n    'Migration completed successfully' as status,\n    COUNT(*) as total_employees,\n    COUNT(DISTINCT user_id) as unique_user_ids,\n    COUNT(*) - COUNT(user_id) as null_user_ids\nFROM public.employees;",
    "path": "supabase/migrations/20250808000001_enforce_unique_user_id.sql"
  },
  "20250808000002_admin_write_policies.sql": {
    "sql": "-- Migration: Add admin WITH CHECK policies for write operations\n-- Description: Ensure admin users can reliably perform INSERT/UPDATE operations\n-- Issue: Missing WITH CHECK policies can cause unpredictable write failures for admins\n\n-- Step 1: Add WITH CHECK policies for employees table\nDO $$ \nBEGIN\n    -- Admin INSERT policy\n    IF NOT EXISTS (\n        SELECT 1 FROM pg_policies \n        WHERE schemaname='public' AND tablename='employees' AND policyname='admin_insert_employees'\n    ) THEN\n        CREATE POLICY admin_insert_employees \n        ON public.employees FOR INSERT\n        WITH CHECK (\n            EXISTS (\n                SELECT 1 FROM public.employees me \n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\n            )\n        );\n        RAISE NOTICE 'Created admin_insert_employees policy';\n    ELSE\n        RAISE NOTICE 'Policy admin_insert_employees already exists';\n    END IF;\n\n    -- Admin UPDATE policy (both USING and WITH CHECK)\n    IF NOT EXISTS (\n        SELECT 1 FROM pg_policies \n        WHERE schemaname='public' AND tablename='employees' AND policyname='admin_update_employees'\n    ) THEN\n        CREATE POLICY admin_update_employees \n        ON public.employees FOR UPDATE\n        USING (\n            EXISTS (\n                SELECT 1 FROM public.employees me \n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\n            )\n        )\n        WITH CHECK (\n            EXISTS (\n                SELECT 1 FROM public.employees me \n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\n            )\n        );\n        RAISE NOTICE 'Created admin_update_employees policy';\n    ELSE\n        RAISE NOTICE 'Policy admin_update_employees already exists';\n    END IF;\nEND $$;\n\n-- Step 2: Add WITH CHECK policies for assessments table\nDO $$ \nBEGIN\n    -- Admin INSERT policy for assessments\n    IF NOT EXISTS (\n        SELECT 1 FROM pg_policies \n        WHERE schemaname='public' AND tablename='assessments' AND policyname='admin_insert_assessments'\n    ) THEN\n        CREATE POLICY admin_insert_assessments \n        ON public.assessments FOR INSERT\n        WITH CHECK (\n            EXISTS (\n                SELECT 1 FROM public.employees me \n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\n            )\n        );\n        RAISE NOTICE 'Created admin_insert_assessments policy';\n    ELSE\n        RAISE NOTICE 'Policy admin_insert_assessments already exists';\n    END IF;\n\n    -- Admin UPDATE policy for assessments\n    IF NOT EXISTS (\n        SELECT 1 FROM pg_policies \n        WHERE schemaname='public' AND tablename='assessments' AND policyname='admin_update_assessments'\n    ) THEN\n        CREATE POLICY admin_update_assessments \n        ON public.assessments FOR UPDATE\n        USING (\n            EXISTS (\n                SELECT 1 FROM public.employees me \n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\n            )\n        )\n        WITH CHECK (\n            EXISTS (\n                SELECT 1 FROM public.employees me \n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\n            )\n        );\n        RAISE NOTICE 'Created admin_update_assessments policy';\n    ELSE\n        RAISE NOTICE 'Policy admin_update_assessments already exists';\n    END IF;\nEND $$;\n\n-- Step 3: Add WITH CHECK policies for review_cycles table\nDO $$ \nBEGIN\n    -- Admin INSERT policy for review_cycles\n    IF NOT EXISTS (\n        SELECT 1 FROM pg_policies \n        WHERE schemaname='public' AND tablename='review_cycles' AND policyname='admin_insert_review_cycles'\n    ) THEN\n        CREATE POLICY admin_insert_review_cycles \n        ON public.review_cycles FOR INSERT\n        WITH CHECK (\n            EXISTS (\n                SELECT 1 FROM public.employees me \n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\n            )\n        );\n        RAISE NOTICE 'Created admin_insert_review_cycles policy';\n    ELSE\n        RAISE NOTICE 'Policy admin_insert_review_cycles already exists';\n    END IF;\n\n    -- Admin UPDATE policy for review_cycles\n    IF NOT EXISTS (\n        SELECT 1 FROM pg_policies \n        WHERE schemaname='public' AND tablename='review_cycles' AND policyname='admin_update_review_cycles'\n    ) THEN\n        CREATE POLICY admin_update_review_cycles \n        ON public.review_cycles FOR UPDATE\n        USING (\n            EXISTS (\n                SELECT 1 FROM public.employees me \n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\n            )\n        )\n        WITH CHECK (\n            EXISTS (\n                SELECT 1 FROM public.employees me \n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\n            )\n        );\n        RAISE NOTICE 'Created admin_update_review_cycles policy';\n    ELSE\n        RAISE NOTICE 'Policy admin_update_review_cycles already exists';\n    END IF;\nEND $$;\n\n-- Step 4: Add WITH CHECK policies for development_plans table  \nDO $$ \nBEGIN\n    -- Admin INSERT policy for development_plans\n    IF NOT EXISTS (\n        SELECT 1 FROM pg_policies \n        WHERE schemaname='public' AND tablename='development_plans' AND policyname='admin_insert_development_plans'\n    ) THEN\n        CREATE POLICY admin_insert_development_plans \n        ON public.development_plans FOR INSERT\n        WITH CHECK (\n            EXISTS (\n                SELECT 1 FROM public.employees me \n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\n            )\n        );\n        RAISE NOTICE 'Created admin_insert_development_plans policy';\n    ELSE\n        RAISE NOTICE 'Policy admin_insert_development_plans already exists';\n    END IF;\n\n    -- Admin UPDATE policy for development_plans\n    IF NOT EXISTS (\n        SELECT 1 FROM pg_policies \n        WHERE schemaname='public' AND tablename='development_plans' AND policyname='admin_update_development_plans'\n    ) THEN\n        CREATE POLICY admin_update_development_plans \n        ON public.development_plans FOR UPDATE\n        USING (\n            EXISTS (\n                SELECT 1 FROM public.employees me \n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\n            )\n        )\n        WITH CHECK (\n            EXISTS (\n                SELECT 1 FROM public.employees me \n                WHERE me.user_id = auth.uid() AND me.role = 'admin' AND me.is_active = true\n            )\n        );\n        RAISE NOTICE 'Created admin_update_development_plans policy';\n    ELSE\n        RAISE NOTICE 'Policy admin_update_development_plans already exists';\n    END IF;\nEND $$;\n\n-- Step 5: Verification - List all policies created\nSELECT \n    'Policy Summary' as status,\n    tablename,\n    policyname,\n    cmd as operation,\n    CASE WHEN qual IS NOT NULL THEN 'USING' END as using_clause,\n    CASE WHEN with_check IS NOT NULL THEN 'WITH CHECK' END as with_check_clause\nFROM pg_policies \nWHERE schemaname = 'public' \n  AND policyname LIKE 'admin_%'\nORDER BY tablename, policyname;",
    "path": "supabase/migrations/20250808000002_admin_write_policies.sql"
  },
  "20250808000003_performance_indexes.sql": {
    "sql": "-- Migration: Add performance indexes for RLS hotpaths and common joins\n-- Description: Optimize query performance for RLS policies and frequently joined columns\n\n-- Step 1: Index for active manager lookups (common in RLS policies)\nCREATE INDEX IF NOT EXISTS ix_employees_manager_active \nON public.employees(manager_id) \nWHERE is_active = true;\n\n-- Step 2: Index for employee + review cycle joins (very common)\nCREATE INDEX IF NOT EXISTS ix_assessments_employee_cycle \nON public.assessments(employee_id, review_cycle_id);\n\n-- Step 3: Index for user_id lookups (critical for RLS performance)\nCREATE INDEX IF NOT EXISTS ix_employees_user_id_active\nON public.employees(user_id)\nWHERE is_active = true;\n\n-- Step 4: Index for employee role lookups (admin checks)\nCREATE INDEX IF NOT EXISTS ix_employees_role_active\nON public.employees(role)\nWHERE is_active = true;\n\n-- Step 5: Index for kudos display and filtering\nCREATE INDEX IF NOT EXISTS ix_kudos_created\nON public.kudos(created_at DESC);\n\n-- Step 6: Conditional indexes based on actual table structure\nDO $$\nBEGIN\n    -- Check if team_health_pulse_responses table exists with correct columns\n    IF EXISTS (\n        SELECT 1 FROM information_schema.columns \n        WHERE table_schema = 'public' \n        AND table_name = 'team_health_pulse_responses' \n        AND column_name = 'submitted_at'\n    ) THEN\n        CREATE INDEX IF NOT EXISTS ix_pulse_responses_employee_date\n        ON public.team_health_pulse_responses(employee_id, submitted_at);\n        RAISE NOTICE 'Created index on pulse responses';\n    ELSE\n        RAISE NOTICE 'Skipped pulse responses index - table/column not found';\n    END IF;\n\n    -- Check if development_plans table exists with manager_approved column\n    IF EXISTS (\n        SELECT 1 FROM information_schema.columns \n        WHERE table_schema = 'public' \n        AND table_name = 'development_plans'\n        AND column_name = 'manager_approved'\n    ) THEN\n        CREATE INDEX IF NOT EXISTS ix_development_plans_employee_approved\n        ON public.development_plans(employee_id, manager_approved);\n        RAISE NOTICE 'Created index on development plans with manager_approved';\n    ELSIF EXISTS (\n        SELECT 1 FROM information_schema.tables \n        WHERE table_schema = 'public' \n        AND table_name = 'development_plans'\n    ) THEN\n        -- Table exists but column doesn't - create basic employee index\n        CREATE INDEX IF NOT EXISTS ix_development_plans_employee\n        ON public.development_plans(employee_id);\n        RAISE NOTICE 'Created basic index on development plans (manager_approved column not found)';\n    ELSE\n        RAISE NOTICE 'Skipped development plans index - table not found';\n    END IF;\n\n    -- Check if assessments table has type column\n    IF EXISTS (\n        SELECT 1 FROM information_schema.columns \n        WHERE table_schema = 'public' \n        AND table_name = 'assessments'\n        AND column_name = 'type'\n    ) THEN\n        CREATE INDEX IF NOT EXISTS ix_assessments_status_type\n        ON public.assessments(status, type);\n        RAISE NOTICE 'Created index on assessments status and type';\n    ELSE\n        -- Create basic status index without type\n        CREATE INDEX IF NOT EXISTS ix_assessments_status\n        ON public.assessments(status);\n        RAISE NOTICE 'Created basic status index on assessments (type column not found)';\n    END IF;\nEND $$;\n\n-- Verification: Display created indexes\nSELECT \n    'Index Summary' as status,\n    schemaname,\n    tablename, \n    indexname,\n    indexdef\nFROM pg_indexes \nWHERE schemaname = 'public'\n  AND indexname LIKE 'ix_%'\nORDER BY tablename, indexname;",
    "path": "supabase/migrations/20250808000003_performance_indexes.sql"
  },
  "20250808000004_set_based_review_seeding.sql": {
    "sql": "-- Migration: Replace row-loop seeding with set-based operations\n-- Description: Create scalable, idempotent review cycle seeding functions\n-- Issue: Current seeding may use inefficient row-by-row loops instead of set operations\n\n-- Function: Seed self-assessments for all active employees in a review cycle\nCREATE OR REPLACE FUNCTION seed_self_assessments(p_review_cycle_id UUID)\nRETURNS TABLE(\n    employees_processed INTEGER,\n    assessments_created INTEGER,\n    assessments_existing INTEGER\n) \nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n    total_employees INTEGER;\n    new_assessments INTEGER;\n    existing_assessments INTEGER;\nBEGIN\n    -- Count total active employees\n    SELECT COUNT(*) INTO total_employees\n    FROM employees \n    WHERE is_active = true;\n    \n    -- Set-based insert with conflict handling\n    INSERT INTO assessments (employee_id, review_cycle_id, status, created_at)\n    SELECT \n        e.id,\n        p_review_cycle_id,\n        'draft',\n        now()\n    FROM employees e\n    WHERE e.is_active = true\n    ON CONFLICT (employee_id, review_cycle_id) DO NOTHING;\n    \n    -- Count what was actually inserted\n    GET DIAGNOSTICS new_assessments = ROW_COUNT;\n    \n    -- Calculate existing assessments\n    existing_assessments := total_employees - new_assessments;\n    \n    -- Log the operation\n    RAISE NOTICE 'Seeded % assessments for review cycle %, % already existed', \n        new_assessments, p_review_cycle_id, existing_assessments;\n    \n    -- Return summary\n    RETURN QUERY SELECT total_employees, new_assessments, existing_assessments;\nEND;\n$$;\n\n-- Function: Combined seeding for review cycle assessments\nCREATE OR REPLACE FUNCTION seed_review_cycle_assessments(p_review_cycle_id UUID)\nRETURNS TABLE(\n    cycle_name TEXT,\n    total_employees INTEGER,\n    assessments_created INTEGER,\n    assessments_existing INTEGER\n)\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n    v_cycle_name TEXT;\n    seed_result RECORD;\nBEGIN\n    -- Verify review cycle exists and get name\n    SELECT name INTO v_cycle_name\n    FROM review_cycles\n    WHERE id = p_review_cycle_id;\n    \n    IF v_cycle_name IS NULL THEN\n        RAISE EXCEPTION 'Review cycle % not found', p_review_cycle_id;\n    END IF;\n    \n    -- Seed assessments using the simpler function\n    SELECT * INTO seed_result\n    FROM seed_self_assessments(p_review_cycle_id);\n    \n    -- Return comprehensive summary\n    RETURN QUERY SELECT \n        v_cycle_name,\n        seed_result.employees_processed,\n        seed_result.assessments_created,\n        seed_result.assessments_existing;\nEND;\n$$;\n\n-- Grant execute permissions to authenticated users (admins will use this via RLS)\nGRANT EXECUTE ON FUNCTION seed_self_assessments(UUID) TO authenticated;\nGRANT EXECUTE ON FUNCTION seed_review_cycle_assessments(UUID) TO authenticated;\n\n-- Add helpful comments\nCOMMENT ON FUNCTION seed_self_assessments(UUID) IS \n'Set-based seeding of assessments for all active employees. Idempotent via ON CONFLICT.';\n\nCOMMENT ON FUNCTION seed_review_cycle_assessments(UUID) IS \n'Complete seeding function for review cycle assessments. Returns detailed summary.';\n\n-- Safe verification without testing (avoids UUID casting issues)\nDO $$\nDECLARE\n    cycle_count INTEGER;\nBEGIN\n    -- Count existing review cycles\n    SELECT COUNT(*) INTO cycle_count FROM review_cycles;\n    \n    IF cycle_count > 0 THEN\n        RAISE NOTICE 'Functions created successfully. Found % review cycles available for seeding.', cycle_count;\n        RAISE NOTICE 'To test: SELECT * FROM seed_review_cycle_assessments(''your-cycle-id-here'');';\n    ELSE\n        RAISE NOTICE 'Functions created successfully. No review cycles found - create one to test seeding.';\n    END IF;\n    \n    RAISE NOTICE 'Migration completed: Set-based review seeding functions are ready for use.';\nEND $$;",
    "path": "supabase/migrations/20250808000004_set_based_review_seeding.sql"
  }
}